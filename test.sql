-- structure.sql (PostgreSQL)

-- Extensions ---------------------------------------------------------------
-- (plpgsql зазвичай доступний, рядок нижче безпечний)
CREATE EXTENSION IF NOT EXISTS plpgsql;

-- Users --------------------------------------------------------------------
CREATE TABLE public.users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR(255) NOT NULL,
  full_name VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL DEFAULT 'user',
  active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_users_on_email ON public.users(email);

-- Parties ------------------------------------------------------------------
CREATE TABLE public.parties (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_type VARCHAR(32) NOT NULL,
  status VARCHAR(32) NOT NULL DEFAULT 'active',
  source_origin VARCHAR(32) NOT NULL DEFAULT 'manual',
  source_ref VARCHAR(255),
  owner_id BIGINT,
  verification JSONB NOT NULL DEFAULT '{}'::jsonb,
  custom_fields JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  CONSTRAINT parties_party_type_chk CHECK (party_type IN ('organization','person')),
  CONSTRAINT parties_status_chk CHECK (status IN ('new','active','inactive','archived')),
  CONSTRAINT parties_source_origin_chk CHECK (source_origin IN ('manual','import','website'))
);
ALTER TABLE public.parties
  ADD CONSTRAINT parties_owner_fk
  FOREIGN KEY (owner_id) REFERENCES public.users(id);

-- Organizations ------------------------------------------------------------
CREATE TABLE public.organizations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  industry VARCHAR(255),
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_organizations_on_party_id ON public.organizations(party_id);
ALTER TABLE public.organizations
  ADD CONSTRAINT organizations_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Party names (multilingual) ----------------------------------------------
CREATE TABLE public.party_names (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  kind VARCHAR(32) NOT NULL DEFAULT 'official',
  name VARCHAR(512) NOT NULL,
  language_code VARCHAR(16),
  "primary" BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  CONSTRAINT party_names_kind_chk CHECK (kind IN ('official','alias'))
);
CREATE INDEX index_party_names_on_party_id ON public.party_names(party_id);
CREATE UNIQUE INDEX index_party_names_uniqueness
  ON public.party_names(party_id, name, language_code);
ALTER TABLE public.party_names
  ADD CONSTRAINT party_names_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- People -------------------------------------------------------------------
CREATE TABLE public.people (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  birth_date DATE,
  gender VARCHAR(32),
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_people_on_party_id ON public.people(party_id);
ALTER TABLE public.people
  ADD CONSTRAINT people_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Tags ---------------------------------------------------------------------
CREATE TABLE public.tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  "group" VARCHAR(255),
  color VARCHAR(64),
  active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_tags_on_name ON public.tags(name);

CREATE TABLE public.taggings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag_id BIGINT NOT NULL,
  party_id BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_taggings_on_tag_and_party ON public.taggings(tag_id, party_id);
ALTER TABLE public.taggings
  ADD CONSTRAINT taggings_tag_fk FOREIGN KEY (tag_id) REFERENCES public.tags(id);
ALTER TABLE public.taggings
  ADD CONSTRAINT taggings_party_fk FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Identities (EDRPOU / RNOKPP / INN ...) ----------------------------------
CREATE TABLE public.identities (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  id_type VARCHAR(64) NOT NULL,
  value VARCHAR(128) NOT NULL,
  country VARCHAR(64),
  verification_status VARCHAR(32) NOT NULL DEFAULT 'unverified',
  valid_from DATE,
  valid_to DATE,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_identities_on_type_and_value
  ON public.identities(id_type, value);
CREATE INDEX index_identities_on_party_id ON public.identities(party_id);
ALTER TABLE public.identities
  ADD CONSTRAINT identities_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Contact channels ---------------------------------------------------------
CREATE TABLE public.contact_channels (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  kind VARCHAR(32) NOT NULL,
  value VARCHAR(255) NOT NULL,
  normalized_value VARCHAR(255),
  purpose VARCHAR(64) NOT NULL,
  is_primary BOOLEAN NOT NULL DEFAULT FALSE,
  verification_status VARCHAR(32) NOT NULL DEFAULT 'unverified',
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  CONSTRAINT contact_channels_kind_chk CHECK (kind IN ('email','phone','other'))
);
CREATE INDEX index_contact_channels_on_party_id ON public.contact_channels(party_id);
CREATE UNIQUE INDEX index_contact_channels_on_normalized_value_kind
  ON public.contact_channels(normalized_value, kind)
  WHERE normalized_value IS NOT NULL;
CREATE UNIQUE INDEX index_contact_channels_primary_per_purpose
  ON public.contact_channels(party_id, purpose)
  WHERE is_primary;
ALTER TABLE public.contact_channels
  ADD CONSTRAINT contact_channels_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Addresses ----------------------------------------------------------------
CREATE TABLE public.addresses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  kind VARCHAR(32) NOT NULL,
  country VARCHAR(64),
  region VARCHAR(128),
  city VARCHAR(128),
  postal_code VARCHAR(32),
  street1 VARCHAR(255),
  street2 VARCHAR(255),
  building VARCHAR(64),
  apartment VARCHAR(64),
  lat NUMERIC(10,6),
  lng NUMERIC(10,6),
  delivery_service VARCHAR(64),
  pickup_point_ref VARCHAR(128),
  is_default BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_addresses_default_per_kind
  ON public.addresses(party_id, kind)
  WHERE is_default;
CREATE INDEX index_addresses_on_party_id ON public.addresses(party_id);
ALTER TABLE public.addresses
  ADD CONSTRAINT addresses_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Social profiles & websites -----------------------------------------------
CREATE TABLE public.social_profiles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  network VARCHAR(64) NOT NULL,
  url VARCHAR(1024) NOT NULL,
  username VARCHAR(255),
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_social_profiles_on_party_and_network
  ON public.social_profiles(party_id, network);
ALTER TABLE public.social_profiles
  ADD CONSTRAINT social_profiles_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

CREATE TABLE public.websites (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  url VARCHAR(1024) NOT NULL,
  "primary" BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_websites_primary_per_party
  ON public.websites(party_id)
  WHERE "primary";
ALTER TABLE public.websites
  ADD CONSTRAINT websites_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Relationships between parties -------------------------------------------
CREATE TABLE public.relationships (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  from_party_id BIGINT NOT NULL,
  to_party_id BIGINT NOT NULL,
  relationship_type VARCHAR(64) NOT NULL,
  role_title VARCHAR(255),
  is_primary BOOLEAN NOT NULL DEFAULT FALSE,
  valid_from DATE,
  valid_to DATE,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE INDEX index_relationships_on_from_party_id ON public.relationships(from_party_id);
CREATE INDEX index_relationships_on_to_party_id ON public.relationships(to_party_id);
CREATE UNIQUE INDEX index_relationships_primary_employee_per_org
  ON public.relationships(to_party_id)
  WHERE (relationship_type = 'employee' AND is_primary);
ALTER TABLE public.relationships
  ADD CONSTRAINT relationships_from_party_fk
  FOREIGN KEY (from_party_id) REFERENCES public.parties(id);
ALTER TABLE public.relationships
  ADD CONSTRAINT relationships_to_party_fk
  FOREIGN KEY (to_party_id) REFERENCES public.parties(id);

-- Consents -----------------------------------------------------------------
CREATE TABLE public.consents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_id BIGINT NOT NULL,
  consent_type VARCHAR(64) NOT NULL,
  status VARCHAR(32) NOT NULL,
  granted_at TIMESTAMP,
  revoked_at TIMESTAMP,
  source VARCHAR(255),
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  CONSTRAINT consents_status_chk CHECK (status IN ('given','revoked'))
);
CREATE UNIQUE INDEX index_consents_given_unique
  ON public.consents(party_id, consent_type)
  WHERE status = 'given';
ALTER TABLE public.consents
  ADD CONSTRAINT consents_party_fk
  FOREIGN KEY (party_id) REFERENCES public.parties(id);

-- Dedupe support -----------------------------------------------------------
CREATE TABLE public.duplicate_candidates (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  party_a_id BIGINT NOT NULL,
  party_b_id BIGINT NOT NULL,
  similarity_score DOUBLE PRECISION NOT NULL DEFAULT 0.0,
  status VARCHAR(32) NOT NULL DEFAULT 'pending',
  signals JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  CONSTRAINT duplicate_candidates_status_chk CHECK (status IN ('pending','reviewed','merged','dismissed'))
);
CREATE UNIQUE INDEX index_duplicate_candidates_on_pair
  ON public.duplicate_candidates(party_a_id, party_b_id);
ALTER TABLE public.duplicate_candidates
  ADD CONSTRAINT dupcand_party_a_fk FOREIGN KEY (party_a_id) REFERENCES public.parties(id);
ALTER TABLE public.duplicate_candidates
  ADD CONSTRAINT dupcand_party_b_fk FOREIGN KEY (party_b_id) REFERENCES public.parties(id);

-- Merge / Split operations --------------------------------------------------
CREATE TABLE public.merge_operations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  actor_id BIGINT NOT NULL,
  target_party_id BIGINT NOT NULL,
  source_party_ids JSONB NOT NULL DEFAULT '[]'::jsonb,
  field_decisions JSONB NOT NULL DEFAULT '{}'::jsonb,
  relinked_objects JSONB NOT NULL DEFAULT '{}'::jsonb,
  performed_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL
);
ALTER TABLE public.merge_operations
  ADD CONSTRAINT merge_ops_actor_fk FOREIGN KEY (actor_id) REFERENCES public.users(id);
ALTER TABLE public.merge_operations
  ADD CONSTRAINT merge_ops_target_party_fk FOREIGN KEY (target_party_id) REFERENCES public.parties(id);

CREATE TABLE public.split_operations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  actor_id BIGINT NOT NULL,
  original_party_id BIGINT NOT NULL,
  restored_party_id BIGINT NOT NULL,
  redistribution JSONB NOT NULL DEFAULT '{}'::jsonb,
  performed_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL
);
ALTER TABLE public.split_operations
  ADD CONSTRAINT split_ops_actor_fk FOREIGN KEY (actor_id) REFERENCES public.users(id);
ALTER TABLE public.split_operations
  ADD CONSTRAINT split_ops_original_party_fk FOREIGN KEY (original_party_id) REFERENCES public.parties(id);
ALTER TABLE public.split_operations
  ADD CONSTRAINT split_ops_restored_party_fk FOREIGN KEY (restored_party_id) REFERENCES public.parties(id);

-- Audit log -----------------------------------------------------------------
CREATE TABLE public.audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  auditable_type VARCHAR(255) NOT NULL,
  auditable_id BIGINT NOT NULL,
  actor_id BIGINT,
  action VARCHAR(64) NOT NULL,
  changeset JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX index_audit_logs_on_auditable ON public.audit_logs(auditable_type, auditable_id);
ALTER TABLE public.audit_logs
  ADD CONSTRAINT audit_logs_actor_fk FOREIGN KEY (actor_id) REFERENCES public.users(id);

-- Active Storage (Rails) ---------------------------------------------------
CREATE TABLE public.active_storage_blobs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key VARCHAR(255) NOT NULL,
  filename VARCHAR(255) NOT NULL,
  content_type VARCHAR(255),
  metadata TEXT,
  byte_size BIGINT NOT NULL,
  checksum VARCHAR(255),
  created_at TIMESTAMP NOT NULL,
  service_name VARCHAR(255) NOT NULL
);
CREATE UNIQUE INDEX index_active_storage_blobs_on_key ON public.active_storage_blobs(key);

CREATE TABLE public.active_storage_attachments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  record_type VARCHAR(255) NOT NULL,
  record_id BIGINT NOT NULL,
  blob_id BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX index_active_storage_uniqueness
  ON public.active_storage_attachments(record_type, record_id, name, blob_id);
ALTER TABLE public.active_storage_attachments
  ADD CONSTRAINT active_storage_attachments_blob_fk
  FOREIGN KEY (blob_id) REFERENCES public.active_storage_blobs(id);

CREATE TABLE public.active_storage_variant_records (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blob_id BIGINT NOT NULL,
  variation_digest VARCHAR(255) NOT NULL
);
CREATE UNIQUE INDEX index_active_storage_variant_records_uniqueness
  ON public.active_storage_variant_records(blob_id, variation_digest);
ALTER TABLE public.active_storage_variant_records
  ADD CONSTRAINT active_storage_variant_records_blob_fk
  FOREIGN KEY (blob_id) REFERENCES public.active_storage_blobs(id);
